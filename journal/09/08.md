# Day 6

i know that python uses a try-catch exception style of error handling but i've been redpilled by Rust's way of handling errors so im gonna look for a result type i can use in the package index, otherwise i'm probably going to make it myself :)
so far, this seems the most promissing: `https://pypi.org/project/result/`.
i also learned from this package that python now has an elegant match statement like in rust! nice!

---

now, i'm to the point where i have to save what i'm reading to the DB. i found a [stackoverflow answer](https://stackoverflow.com/questions/18621513/python-insert-numpy-array-into-sqlite3-database) that says we can save entire numpy arrays in sqlite, which is pretty cool and make this whole saving buisness extremely easy.

---

i had to find a way to fetch the records one by one through a generator instead of a list in case the dataset is too big to fit in memory. turns out, its simpler than i thought it would be:

```py
cursor = db.execute("SELECT customer FROM table")
for row in cursor:
            print row[0]
# instead of
cursor = db.execute("SELECT customer FROM table")
for row in cursor.fetchall(): # this one returns a list instead of a generator
            print row[0]

```

[source](https://stackoverflow.com/questions/21334767/is-sqlite3-fetchall-necessary)

i don't know if i said why i wanted a generator, but it's because in python, generators are lazy. so, instead of fetching all data and transforming it in place, the generator will get entries as they are needed and i can even map over them lazily by wrapping the generator in another generator, through a _list comprehention_.

---

i made it so you can pass a flag to make it reset the database. the flag is `--reset_db`. this makes me thing i should add a `README.md` eventually.

---

im having a bit of trouble figuring out how to insert in the db without having to supply all the fields (they should be automatically handled)